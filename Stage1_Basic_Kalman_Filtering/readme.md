模拟实际动态规律 (Actual Law of Motion)
===

第一步是在给定参数下模拟真实经济变量的演化路径。这一过程被设定为标准的 AR(1) 模型，即当前值由前一期值按一定比例延续，并受到随机冲击影响。

具体模拟公式：
$$
y_t = \rho_{\text{true}} \, y_{t-1} + \varepsilon_t, \qquad \varepsilon_t \sim N(0,\,\sigma_\varepsilon^2),
$$
其中 $y_t$ 表示第 $t$ 期的真实经济变量（例如 GDP、失业率等），对其他数值进行设定，随后通过循环迭代计算，从 $t=2$ 到 $T$ 的递推，每期按照law of motion推进：上一期的水平乘以0.5，再加上一个random shock/noise。

**经济学含义：** AR(1) 模型捕捉了许多宏观经济时间序列的惯性特征：当前的经济状况部分延续过去（由$\rho_{\text{true}}$决定延续程度），同时叠加不可预测的新冲击。

预测者观测噪声信号并更新信念 (Kalman Filter更新)
===

设置 $M=100$ ，表示100位预测者对经济变量的观测过程，每位预测者只能看到带有噪声的信号，并利用类似卡尔曼滤波的规则来更新对真实变量的信念。这一步骤反映了信息不完全情况下预测者如何提取有用信息。具体而言，**第 $t$ 期每位预测者 $i$ 观测到的信号**由真实值加上噪声构成：
$$
S_{i,t} = y_t + \omega \cdot \nu_{i,t},
$$
其中 $S_{i,t}$ 表示预测者 $i$ 在$t$期看到的信号，$y_t$是真实值，$\nu_{i,t}\sim N(0,1)$ 是标准正态噪声，$\omega$是信号噪声的标准差（代码中设定$\omega=0.5$）。噪声越小，信号越精准，**$\omega$较小意味着观测几乎贴近真实值**；反之 $\omega$ 大，信号可靠性就差，预测者会质疑其中是否包含较大随机波动。代码中通过 `signals(i,t-1) = y(t-1) + omega * randn()` 生成每位预测者在每一期的观测值。

得到观测信号后，预测者需要结合先验，对真实变量进行贝叶斯更新。这里采用了**卡尔曼滤波的线性最优估计公式**。一般地，如果预测者对 $y_{t}$ 的先验分布为正态（均值$\bar{y}*{t|t-1}$，方差$P*{t|t-1}$），观察到信号 $S_{i,t}$ 后，其后验最优估计为：
$$
\hat{y}_{i,t|t} = \bar{y}_{t|t-1} + K_t \big( S_{i,t} - \bar{y}_{t|t-1} \big),
$$
其中 $K_t$ 是**卡尔曼增益**，计算公式为 $K_t = \frac{P_{t|t-1}}{P_{t|t-1} + \omega^2}$。$K_t$ 衡量了预测者相信观测信号的程度：如果信号噪声方差$\omega^2$较小（信号精度高），$K_t$接近1，预测者几乎完全信任信号；若噪声方差大，$K_t$接近0，预测者会更依赖先验。

在本代码中，为简化计算，假设各期 $K$ 不随时间变化且先验均值初始为0。并且代码直接采用稳态增益 $K = \frac{1}{1+\omega^2}$ 进行更新。代入$\omega=0.5$，可得 $K = \frac{1}{1+0.25} = 0.8$。这表示预测者将信号的80%权重用于校正对真实变量的估计（因为先验方差在此框架下等同于信号方差的量级）。每期 $t$ 的后验信念（记作 $\hat{y}_{i,t}$）直接用信号乘以 $K$：
$$
\hat{y}_{i,t} \approx K \cdot S_{i,t} = \frac{1}{1+\omega^2} (y_t + \omega \nu_{i,t})\,,
$$
在code中对应的是 `yhat(i,t-1) = K * signals(i,t-1)`。由于在循环里 $t-1$ 表示信念对应的是对上一期真实值的估计/信念，经过这一更新步骤，每个预测者在每期都得到对真实状态的最优线性估计 $\hat{y}_{i,t}$。

防遗忘：`signals(i,t)` 保存了预测者$i$在$t$期观察到的信号值，`yhat(i,t)` 则是预测者$i$对真实变量$y_t$的信念（后验估计）。

> 卡尔曼滤波在宏观经济学中常用于建模预测者如何从带噪信息中学习真实状态。例如，中央银行或市场参与者可能只能观察到带有统计误差或临时波动的经济指标，需要通过过滤提取潜在的真实趋势。这里预测者通过赋予观测信号0.8的权重来更新对经济变量的看法，体现了“有限信息理性”或“噪声信念”的思想：他们不是全知的，而是根据不完美的信息进行最佳线性更新。

构造预测者的主观预测 (Perceived Law of Motion)
===

在形成对未来的预测时，每位预测者都会将自己对当前状态的信念代入其所相信的（**主观的**）动态规律中去推断下一期的值。这一步对应代码中的 Step 3。假定预测者认为经济变量遵循一个与实际可能不符的一个 AR(1) 过程，其系数为主观估计的 $\rho*{\text{hat}}$。代码中 $\rho_{\text{hat}}=0.8$，显著高于真实的0.5，表示预测者**高估了**变量的持续性。预测步长由参数 $h$ 决定（这里 $h=1$ 表示一阶预测，即预测下一期），因此预测者的**主观动态规律**可以表示为：
$$
y_{t+1} = \rho_{\text{hat}} \, y_t + \tilde{\varepsilon}_{t+1}\,,
$$
其中$\tilde{\varepsilon}$表示预测者模型中的随机扰动项（他们通常假设平均为0，无法预测）。

基于此模型，预测者$i$在$t$期对未来$h$期（这里即下一期）的预测为（应该对）：
$$
F^{(i)}_{t,t+h} = \mathbb{E}[\,y_{t+h} \mid \text{信息}_t^{(i)}\,] = (\rho_{\text{hat}})^h \, \hat{y}_{i,t}\,. 
$$
考虑情况$h=1$，公式简化为 $F^{(i)}*{t,t+1} = \rho*{\text{hat}} , \hat{y}*{i,t}$。代码中对应 `pred(i,t) = rho_hat^h \* yhat(i,t)`（由于$h=1$，实质是$\rho*{\text{hat}} \cdot \hat{y}_{i,t}$）。这一步表明：**每位预测者依据自己对当期的最佳估计，再乘以主观系数0.8，得到对下一期的预测**。

> AR(1)模型在预测中扮演了简单但关键的角色——它捕捉了预测者对于经济动态的认知。如果预测者准确掌握了真实规律，那么 $\rho_{\text{hat}}$ 应接近 $\rho_{\text{true}}$；但当存在认知偏差时（如本例中$\rho_{\text{hat}}=0.8$远高于真实0.5），就属于misperceived的情形。高估持续性意味着预测者认为冲击的影响更持久，因此会在正向冲击后预测更高的未来值（或在负向冲击后预测更低）。这种系统性偏差将导致可预测的预测误差，从而为我们提供辨识其误识动态的线索。

共识预测与实际值对齐
===

由于有 $M=100$ 位预测者，代码第4步将所有预测者的预测取平均，以代表整体的所谓**共识预测**（consensus forecast）。具体实现是对`pred(i,t)`在$i$维度取均值，得到每个时间$t$的平均预测 $F_{t,t+h}$。数学上：
$$
F_{t,t+h} = \frac{1}{M} \sum_{i=1}^M F^{(i)}_{t,t+h} = \frac{1}{M} \sum_{i=1}^M (\rho_{\text{hat}})^h \hat{y}_{i,t}\,. 
$$
在代码中这一结果保存在向量 `Ft_ytph` 中（表示在$t$期针对$t+h$期的共识预测，h=1时可理解为“对未来1期的预测”）。由于先前每位预测者的观测噪声是独立的，取平均可以在很大程度上相互抵消噪声影响，使共识预测比单个预测者更接近于真实期望。因此，共识预测可以视为聚合了信息的**“智慧平均”**，常用于实际研究中作为总体预期的代理。

随后，代码提取与预测对应的实际值系列用于比较：将真实序列 $y_t$ 移动 $h$ 期来对齐预测。例如，当$h=1$时，`yt = y(1:T-1)` 对应预测时刻的实际当期值（$y_1,...,y_{T-1}$），`ytph = y(2:T)` 则是各预测所要预测的下一期实际值（$y_2,...,y_T$）。这样就得到三组对齐的时间序列：

- $y_t$：当期实际值序列 (长度 $T-h$)，
- $y_{t+h}$：对应未来$h$期后的**实际值**序列 (同样长度)，
- $F_{t,t+h}$：预测者在当期对未来$h$期的**共识预测**序列 (长度 $T-h$)。

在代码中，这三者分别为 `yt`, `ytph`, `Ft_ytph`。这一对齐为后续统计分析做准备，即可以逐期比较预测和实际结果的关系。

计算统计量 (7) – Self-Adjoint
===

完成上述模拟后，代码进入**统计指标计算**部分。首先计算的是**公式 (7)** 对应的统计量。代码通过样本协方差实现这一比值的计算：

```matlab
matlabCopyEditcov1 = cov(Ft_ytph, yt);
cov2 = cov(ytph, Ft_ytph);
stat_eq7(rep) = cov1(1,2) / cov2(1,2);
```

其中 `cov(X,Y)` 返回向量 $X$ 和 $Y$ 的协方差矩阵。在本例中，`cov1(1,2)` 实际上是 $\mathrm{Cov}(F_{t,t+h},,y_t)$，而 `cov2(1,2)` 是 $\mathrm{Cov}(y_{t+h},,F_{t,t+h})$。表示为：
$$
\text{Stat}_{(7)} \;=\; \frac{\mathrm{Cov}\!\big(F_{t,t+h},\,y_t\big)}{\mathrm{Cov}\!\big(y_{t+h},\,F_{t,t+h}\big)}\,.
$$
这一比率检验的是预测结构在时间上的某种对称性（Self-Adjoint）。直观来说，分子度量**预测与当前实际**的协动关系，分母度量**预测与未来实际**的协动关系。如果预测者的模型和行为在动态上是对称合理的，我们可能期待这两种协方差关系满足一定的比例结构。比如，在理性预期且完全信息的理想情形下，预测$F_{t,t+1}$基本上是$\rho_{\text{true}} y_t$的线性函数，即考虑：
$$
F_{t,t+1} = \rho_{\text{true}} \cdot y_t
$$
所以：
$$
\mathrm{Cov}(F_{t,t+1}, y_t) = \mathrm{Cov}(\rho_{\text{true}} y_t, y_t) = \rho_{\text{true}} \cdot \mathrm{Var}(y_t)
$$
同时我们知道：
$$
y_{t+1} = \rho_{\text{true}} \cdot y_t + \varepsilon_{t+1}, \quad \text{且} \quad F_{t,t+1} = \rho_{\text{true}} y_t
$$
由于 $\varepsilon_{t+1}$ 与 $y_t$（进而与 $F_{t,t+1}$）独立，所以下式成立：
$$
\mathrm{Cov}(y_{t+1}, F_{t,t+1}) = \mathrm{Cov}(\rho_{\text{true}} y_t + \varepsilon_{t+1}, \rho_{\text{true}} y_t)
= \rho_{\text{true}} \cdot \mathrm{Cov}(y_t, \rho_{\text{true}} y_t) + \underbrace{\mathrm{Cov}(\varepsilon_{t+1}, F_{t,t+1})}_{=0}
$$

- $\mathrm{Cov}(F_{t,t+1},,y_t) \approx \rho_{\text{true}},\mathrm{Var}(y_t)$,
- $\mathrm{Cov}(y_{t+1},,F_{t,t+1}) \approx \rho_{\text{true}}^2,\mathrm{Var}(y_t)$ （因为 $y_{t+1} \approx \rho_{\text{true}} y_t$ 且预测与$y_t$高度相关）。

则上述比值大致为 $1/\rho_{\text{true}}$。在本模型中$\rho_{\text{true}}=0.5$，因此若预测结构与真实动态一致，我们预期 $\text{Stat}_{(7)} \approx 1/0.5 = 2$ 左右。

**结果解读：** 由于预测者存在误识动态（$\rho_{\text{hat}} \neq \rho_{\text{true}}$），我们想检验此统计量能否反映出异常。从蒙特卡洛模拟得到的 $\text{Stat}*{(7)}$ 分布来看，其数值平均约为 2.2（具体结果下面会结合bootstrap给出）。与理想值2相比略有偏差，但差异并不显著。事实上，这是因为**(7) 对误识参数并不敏感**：在我们的模型下，$\text{Stat}*{(7)}$ 近似等于 $1/\rho_{\text{true}}$，主要由真实动态决定，基本独立于预测者主观认知的$\rho_{\text{hat}}$（只受到微小的噪声影响）。因此，即使预测者误判了动态结构，公式(7)计算的比率仍然接近一个由真实模型决定的常数，在识别误识动态方面效果有限？

计算统计量 (8) – 协方差比方法
===

接下来，代码计算**公式 (8)** 对应的统计量。此方法参考了文献（如 Reis 2020）提出的协方差比结构，用于识别结构参数的偏误。代码实现如下：

```matlab
matlabCopyEditcov3 = cov(Ft_ytph, Ft_ytph);
cov4 = cov(ytph, Ft_ytph);
cov5 = cov(yt, yt);
cov6 = cov(ytph, yt);
stat_eq8(rep) = (cov4(1,2)/cov3(1,1)) * (cov5(1,1)/cov6(1,2));
```

将其转换为数学符号，首先注意：`cov4(1,2) = \mathrm{Cov}(y_{t+h},\,F_{t,t+h})`，`cov3(1,1) = \mathrm{Var}(F_{t,t+h})`，`cov5(1,1) = \mathrm{Var}(y_t)`，`cov6(1,2) = \mathrm{Cov}(y_{t+h},\,y_t)`。代入后统计量(8)可表示为：
$$
\text{Stat}_{(8)} \;=\; \frac{\mathrm{Cov}(y_{t+h},\,F_{t,t+h})}{\mathrm{Var}(F_{t,t+h})} \;\times\; \frac{\mathrm{Var}(y_t)}{\mathrm{Cov}(y_{t+h},\,y_t)}\,.
$$
这个表达可以拆解为两部分相乘：

- **第一部分** $\displaystyle \frac{\mathrm{Cov}(y_{t+h},,F_{t,t+h})}{\mathrm{Var}(F_{t,t+h})}$ 是对**预测有效性**的度量，相当于回归$y_{t+h}$关于预测$F_{t,t+h}$的斜率系数（OLS估计值）。它表示共识预测对未来实际的线性解释力：如果预测完全准确，此系数应接近1；若预测系统性偏高或偏低，系数会偏离1。
- **第二部分** $\displaystyle \frac{\mathrm{Var}(y_t)}{\mathrm{Cov}(y_{t+h},,y_t)}$ 则是**实际动态关系**的度量，等于回归$y_{t+h}$关于当前$y_t$斜率的倒数。注意对于真实的AR(1)过程，$\mathrm{Cov}(y_{t+h},y_t) = \rho_{\text{true}},\mathrm{Var}(y_t)$（当$h=1$），因此第二部分近似为 $1/\rho_{\text{true}}$。在我们的设定下，这一值为 $1/0.5 = 2$。

将两部分相乘，$\text{Stat}_{(8)}$ 实际上是在比较**预测的实际斜率**和**真实的自身斜率**。更加直观地，我们可以重新组织公式(8)为：
$$
\text{Stat}_{(8)} \;\approx\; \frac{\displaystyle \frac{\mathrm{Cov}(y_{t+h},\,F_{t,t+h})}{\mathrm{Var}(F_{t,t+h})}}{\displaystyle \frac{\mathrm{Cov}(y_{t+h},\,y_t)}{\mathrm{Var}(y_t)}}\,,
$$
考虑$h=1$：
$$
y_{t+1} = \rho_{\text{true}} y_t + \varepsilon_{t+1}, \quad F_{t,t+1} = \rho_{\text{hat}} y_t
$$
因为 $\varepsilon_{t+1}$ 与 $y_t$ 独立，且与 $F_{t,t+1}$ 也独立，我们有：
$$
\mathrm{Cov}(y_{t+1}, F_{t,t+1}) = \mathrm{Cov}(\rho_{\text{true}} y_t + \varepsilon_{t+1},\ \rho_{\text{hat}} y_t) = \rho_{\text{true}} \rho_{\text{hat}} \cdot \mathrm{Var}(y_t)
$$
因为 $F_{t,t+1} = \rho_{\text{hat}} y_t$，所以：
$$
\mathrm{Var}(F_{t,t+1}) = \rho_{\text{hat}}^2 \cdot \mathrm{Var}(y_t)
$$

$$
\mathrm{Cov}(y_{t+1}, y_t) = \mathrm{Cov}(\rho_{\text{true}} y_t + \varepsilon_{t+1},\ y_t) = \rho_{\text{true}} \cdot \mathrm{Var}(y_t)
$$

将以上代入 (8)：
$$
\text{Stat}_{(8)} = \frac{\rho_{\text{true}} \rho_{\text{hat}} \cdot \mathrm{Var}(y_t)}{\rho_{\text{hat}}^2 \cdot \mathrm{Var}(y_t)} \cdot \frac{\mathrm{Var}(y_t)}{\rho_{\text{true}} \cdot \mathrm{Var}(y_t)}
$$
先把 $\mathrm{Var}(y_t)$ 抵消掉，得到：
$$
\text{Stat}_{(8)} = \frac{\rho_{\text{true}} \rho_{\text{hat}}}{\rho_{\text{hat}}^2} \cdot \frac{1}{\rho_{\text{true}}} = \frac{1}{\rho_{\text{hat}}}
$$
即**预测对实际的回归系数**除以**实际自身的回归系数**。如果预测者的模型是正确的，那么预测基本相当于真实值的线性函数，两者的回归系数应当一致，此比值应接近1。然而，如果预测者误识了动态结构，此比值将显著偏离1。

特别地，在本模型中：当信息充分时（预测者可准确观测 $y_t$），有 $\text{Stat}*{(8)} \approx 1/\rho*{\text{hat}}$。也就是说，**统计量(8)的倒数乘以真实参数$\rho_{\text{true}}$，可以近似得到预测者主观认知的参数$\rho_{\text{hat}}$**。因此，(8)在原理上对误识动态可能更敏感——它几乎直接捕捉到了预测者认为的系数。

**本模拟结果解读：** 我们的之后蒙特卡洛模拟验证了这一点：在$\rho_{\text{true}}=0.5, \rho_{\text{hat}}=0.8$情形下，$\text{Stat}*{(8)}$的数值显著偏离了基准。模拟平均值约为1.56，这与理性无偏情形应有的2.5（= $1/0.4$, 若$\rho*{\text{hat}}=\rho_{\text{true}}=0.5$则$\text{Stat}*{(8)}\approx2.5$)有明显差距。换言之，$\text{Stat}*{(8)} \times \rho_{\text{true}} \approx 0.78$，远低于1，清楚地表明预测者模型中的$\rho_{\text{hat}}$不是0.5而是较大的值。由此可见，**(公式8)也许更能有效识别预测者动态认知的偏差**：它利用预测结果与实际演变之间的结构性差异来推断预测者的错误认知。相比之下，公式(7)由于大致随$\rho_{\text{true}}$决定，可能不好体现$\rho_{\text{hat}}$的影响。

Bootstrap 检验与统计功效 (Power) 分析
===

代码的最后部分对上述统计量进行了Bootstrap检验并评估了检验的区分能力（Power）。具体过程如下：

1. **Bootstrap抽样分布**：将 Monte Carlo 模拟得到的 $N=500$ 组 $\text{Stat}*{(7)}$ 和 $\text{Stat}*{(8)}$ 值分别视作经验分布，从中反复有放回地抽样计算均值。代码设置了 $B=1000$ 次自助抽样迭代，每次从500个模拟值中随机抽取500个（允许重复），计算抽样均值并存入 `boot_stat_eq7` 和 `boot_stat_eq8`。经过 1000 次迭代，就得到两组**均值的自助抽样分布**。
2. **置信区间估计**：将自助分布排序后，代码取分位数来构造均值的95%置信区间。我们模拟的结果显示，$\text{Stat}*{(7)}$均值的95%置信区间大约为 [2.23,;2.37]，而$\text{Stat}*{(8)}$均值的区间约为 [1.558,;1.561]。可以看到，公式(8)的均值置信区间极窄，说明在给定参数下$\text{Stat}*{(8)}$的取值非常稳定集中（这点也从前述方差分析得到印证：$\text{Stat}*{(8)}$在500次模拟中的标准差仅$\approx0.03$，远小于$\text{Stat}*{(7)}$的$\approx0.70$）。这意味着我们对$\text{Stat}_{(8)}$的估计比较精确。
3. **拒绝率（Power）计算**：代码将每次模拟得到的$\text{Stat}*{(7)}$和$\text{Stat}*{(8)}$值与各自均值的置信区间进行比较：若某次模拟的统计量落在置信区间之外，则视为“拒绝”（reject_eq7或reject_eq8标记为1）。随后计算这些拒绝次数的比例，即

$$
\text{Power}_{7} = P\big\{\text{Stat}_{(7)} \notin [ci7\_low, ci7\_high]\big\}, \qquad 
\text{Power}_{8} = P\big\{\text{Stat}_{(8)} \notin [ci8\_low, ci8\_high]\big\}.
$$

代码打印称其为“拒绝率”，可被理解为在当前误识动态下，我们将统计量判定为异常的频率。

需要注意：上述方法实际上并非严格的经典显著性检验，因为它使用了替代分布（误识动态情形）的抽样均值区间来衡量观察值异常与否，而没有明确假设一个原假设$H_0$（如“无误识动态”）下统计量的阈值。不过，这一近似方法仍提供了一种比较两种统计量区分能力的思路：若某统计量对误识动态更加敏感，则在误识情况下其取值更频繁地落入自身均值分布的尾部区域。

**检验结果：** 对500次模拟结果进行上述计算，我们得到公式(7)的拒绝率约为 92% 左右，公式(8)的拒绝率约为 93% 左右（不同随机种子下略有波动，但总体相差不大）。两者数值都很高，这反映出在当前模拟参数下，每次模拟得到的统计量往往远离各自均值（尤其是对于公式8，均值区间极窄，使得大部分观测值都落在区间之外）。虽然数字上二者差距不明显，但结合前面的分析，我们知道**公式(8)在检验误识动态上更具优势**。原因在于：

- $\text{Stat}*{(8)}$ **对误识动态的信号更强**：它在误识情况下与理想基准值偏差巨大。例如，当$\rho*{\text{hat}}=0.8$与真实值相差悬殊时，$\text{Stat}*{(8)}$明显从2.5下降到约1.56，展示出显著的变化。这种大幅偏离使其很容易被检测到。事实上，如果我们以“预测者正确认知”为原假设，那么$\text{Stat}*{(8)}$的观测值几乎必定落在原假设允许范围之外，检验功效接近于1。
- $\text{Stat}*{(7)}$ **对误识动态几乎不敏感**：正如分析，$\text{Stat}*{(7)}$主要由真实AR系数决定，误识带来的影响很小。在我们的误识模拟中，其均值仅从2.29略降至2.19，变化幅度淹没在自身波动之中。换言之，预测者即使使用错误的$\rho_{\text{hat}}$，公式(7)算出的比值仍近似保持$\approx 1/\rho_{\text{true}}$。因此若基于此统计量检验预测者模型是否正确，我们很难拒绝原假设——它缺乏区分真实与误识动态的力量（Power低）。

从经济学角度解释，**公式(8)可能更具区分力**。

Improvement
===

上述代码较清晰地实现了模拟和统计量计算的逻辑，但在结构和方法上仍有改进空间：

- **向量化与效率：** 代码中多处使用了双重循环（如生成预测者信号和更新信念部分）。这在 MATLAB 中可以用向量化方式提升效率。例如，可以一次性生成所有预测者的噪声矩阵 `noise = randn(M, T-1)` 并加到真实值向量上得到 `signals`，然后直接计算 `yhat = K * signals`（这利用了 MATLAB 的逐元素运算）。这样避免了嵌套循环，不仅代码更简洁，也能显著加快运行速度，尤其当 $M$ 或 $T$ 较大时。
- **逻辑合理性：** 当前卡尔曼更新采用固定增益 $K=1/(1+\omega^2)$，相当于假定预测者从一开始就处于稳态信念更新过程。更严格的处理应包含两个阶段：预测（时间更新）和校正（观测更新）。例如，预测者可以在$t-1$期的后验信念基础上用其模型预测$t$期的先验，然后结合$t$期信号更新后验。这需要跟踪每期的信念方差并更新$K_t$。在本模拟中，由于每期都是独立的信号估计，没有利用先前信息，实际相当于每次都假设先验均值0且方差固定。这虽然简化了问题，但在现实中预测者会将过去的信念传递，从而逐步缩小不确定性。**改进建议**：可以实现一个真正的Kalman滤波过程，使$\hat{y}*{i,t}$不仅取决于当前信号，也受上一期$\hat{y}*{i,t-1}$的影响。这样模型更加严谨，能模拟预测者随着时间逐步学习的过程。
- **统计方法合理性：** 目前计算Power的办法比较特殊：它将误识情形自身的均值分布当作基准来衡量观测值异常与否。更标准的做法应该是明确假设一个原假设值或分布，然后计算在备择假设下拒绝原假设的频率。例如，这里的原假设自然是“$\rho_{\text{hat}} = \rho_{\text{true}}$（无误识动态）”。我们可以通过令$\rho_{\text{hat}}=0.5$重复相同模拟，得到在理性情形下统计量(7)和(8)的分布，从而确定相应检验的临界值（比如95%分位数）。然后再用当前误识情况下统计量落入原假设拒绝域的比例来衡量Power。这种方法能更准确地解释检验的显著性和功效。当然，这会增加编程复杂度，需要双重模拟或解析推导临界值。现有代码的Bootstrap思路提供了一种近似，但严格性略有不足。若读者将来扩展研究，应考虑引入正式的假设检验框架。
- **代码可读性：** 可以增加更多注释说明各步骤的目的（例如解释公式7和8的经济含义，正如上文所做的），这有助于其他研究者快速理解代码意图。此外，变量命名可以更具描述性，例如将 `stat_eq7` 改为 `stat_ratio_sym`（表示对称性比率），`stat_eq8` 改为 `stat_ratio_cov` 等，以反映统计量含义。合理分段代码（使用函数或脚本段落）来分别处理“模拟生成数据”、“计算统计量”、“统计检验”模块，也能使结构更清晰。
- **实验设计拓展：** 本代码固定了参数值($\rho_{\text{true}}=0.5$, $\rho_{\text{hat}}=0.8$)。可以考虑对不同程度的误识（例如$\rho_{\text{hat}}$取值在0.5到0.9范围）以及不同噪声水平$\omega$进行敏感性分析。这将有助于全面评估公式(7)和(8)在各种情形下的表现。例如，若噪声$\omega$增大，预测者信念不准，共识预测将更趋近于0（因为Kalman增益变小），这可能影响协方差结构，从而影响统计量值。另外，也可以通过增加模拟重复次数 $N$ 或改变样本长度 $T$ 来检验结果的稳健性。

总之，这段代码围绕一个简单的AR(1)模型，展示了在预测者存在认知偏差情况下如何通过协方差分析来检验和量化这种偏差。通过逐步讲解代码逻辑和背后的经济含义，我们看到：**公式(8)基于协方差比的结构性方法，能够更有力地区分预测者模型的偏误**，而**公式(7)由于缺乏对误识参数的依赖，难以提供有效的辨识信号**。这种分析对于理解宏观预测中长期存在的一些异常现象提供了新视角：当预测一致出现系统性偏误时，我们可以运用类似协方差比的方法来揭示隐藏其中的认知错误或信息局限。